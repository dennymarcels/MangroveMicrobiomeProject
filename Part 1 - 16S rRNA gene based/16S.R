# 1 Setting environment ----

# 1.1 Loading dependencies ----

require(GUniFrac)
require(phangorn)
require(dplyr)
require(heatmap.plus)
require(randomForest)
require(candisc)
require(MASS)
require(mratios)
require(scales)
require(ggplot2)
require(gridExtra)
require(grid)
source('functions.R')
source('Part 1 - 16S rRNA gene based/functions.R')

# 1.2 Defining global variables

study <- '16S'
taxonomy <- c('domain', 'phylum', 'class', 'order', 'family', 'genus')

# 2 Calculating GUniFrac distance ----

# 2.1 Reading and rooting the tree  ----

# The tree was independently generated by Qiime. Rooting is needed for function GUniFrac.
unroot.tree <- read.tree('Part 1 - 16S rRNA gene based/rep_set.tre')
tree <- midpoint(unroot.tree, node.labels = 'label')

# 2.2 Reading and processing the OTU table ----

# The OTU table was independently generated by Qiime.
otu.tab <- t(read.delim('Part 1 - 16S rRNA gene based/otu_table.tsv', skip=1, header=T, row.names=1))
otu.tab <- otu.tab[order(rownames(otu.tab)), ]

# Some OTUs could not have taxonomy assigned, therefore they are not in the tree, and must be removed from the OTU table.
otu.tab <- otu.tab[, colnames(otu.tab) %in% tree$tip.label]

# Rarefaction.
set.seed(1)
otu.tab.rff <- Rarefy(otu.tab)$otu.tab.rff
otu.tab.rff <- otu.tab.rff[order(row.names(otu.tab.rff)),]

# Some OTUs were included in the tree but were removed from the OTU table by posterior processing. They must be included in the OTU table, with count 0.
missing <- as.character(tree$tip.label[!(tree$tip.label %in% colnames(otu.tab.rff))])
missing.matrix <- matrix(rep(0, 30*length(missing), 30, length(missing)), dimnames=list(c(rownames(otu.tab.rff)), c(missing)))
otu.tab.rff <- cbind(otu.tab.rff, missing.matrix)

# 2.3 Calculating GUniFrac distances between samples ----

gunifrac <- GUniFrac(otu.tab.rff, tree, alpha = c(0, 0.5, 1))

# dw <- gunifrac$unifracs[, , 'd_1']		# Weighted UniFrac
# du <- gunifrac$unifracs[, , 'd_UW']		# Unweighted UniFrac	
# dv <- gunifrac$unifracs[, , 'd_VAW']		# Variance adjusted weighted UniFrac
# d0 <- gunifrac$unifracs[, , 'd_0']        # GUniFrac with alpha 0  
d5 <- gunifrac$unifracs[, , 'd_0.5']        # GUniFrac with alpha 0.5 

# 3 Calculating taxa abundances ----

# 3.1 Getting taxa counts ----

# Qiime provides relative taxa abundance, but I would rather work with actual counts as I mean to compare these results to others later, and counts are fit for rarefaction. For such, I will convert the genus abundance table (highest taxonomic resolution provided) into counts.
rowsums <- rowSums(otu.tab)

genus <- t(read.delim('Part 1 - 16S rRNA gene based/table_mc33942_sorted_L6.tsv', row.names=1, skip=1, header=T))
genus <- genus[order(rownames(genus)), ]

genus_counts <- round(genus*rowsums)

# Now I am splitting the genus text (which contains the whole taxonomic tree) into all other taxa.
# First, some genus are 0 across all samples. These will be removed.
taxo16S <- t(genus_counts)
taxo16S <- taxo16S[rowSums(taxo16S) > 0, ]

# Then, I will split the text in rownames into all hierarchical levels, to be inserted as columns.
taxo16S <- split_taxa_in_columns(taxo16S)

# taxo16S contains unclassified taxa indicates simply as 'unclassified'. I would also want to preserve some taxonomic information for these unclassified taxa, appending to its label the first higher order identified for it, as in '(from higher_order)'
taxo16S <- preserve_tax_info(taxo16S)

# Writing this table to disc, it will also be used later for comparison with the other sequencing method
write.table(taxo16S, 'Part 1 - 16S rRNA gene based/taxonomic_counts_16S.tsv', sep = '\t', row.names = F)

# 4 Generating boxplots for the most abundant taxa ----

# 4.1 Rarefying count table ----

counts <- t(taxo16S[, 7:ncol(taxo16S)])
set.seed(1)
counts <- Rarefy(counts)$otu.tab.rff
taxo16S[, 7:ncol(taxo16S)] <- t(counts)

# 4.2 Boxplotting most abundant taxa by taxonomic level ----

boxplots(taxo16S, taxonomy)

# 5 Generating heatmap with hierarchical clustering ----

# 5.1 Reading environmental data ----

env <- read.delim('Part 1 - 16S rRNA gene based/environmental.tsv', row.names=1, check.names = F)

# 5.2 Separating categorical and continuous variables ----

# Categorical variables are Salinity and Plant, and continuous variables are the chemical measurements. Some chemical variables are 0 for all samples, they are filtered out.
fact <- env[, c(2, 3)]
chem <- env[, 5:ncol(env)]; chem <- chem[, colSums(chem) != 0]

# Generating a color list
factors.for.col <- fact
colours.sal <- colorRampPalette(c('black', 'gray'))(length(levels(factors.for.col$salinity)))[factors.for.col$salinity]
colours.plant <- rainbow(length(levels(factors.for.col$plant)), start=0, end=0.65)[factors.for.col$plant]
ann.colors = list('salinity' = colours.sal, 'plant' = colours.plant)

# 5.3 Plotting at all levels (except domain - not informative) ----
for(tax in c(taxonomy[2:length(taxonomy)], 'OTU')){
    if(tax != 'OTU'){
        # Consolidates table at the hierarchical level
        table <- prepare_for_hclust(taxo16S, tax)
        # Calculates Bray-Curtis dissimilarities
        dist <- vegdist(table, 'bray')
    } else{
        # table = OTU table
        table <- otu.tab.rff
        # distance = GUniFrac d(0.5)
        dist <- as.dist(d5)
    }
    # Simplify the table to contain only up to 20 categories
    table <- simplify(table)
    # Hierarchical clustering (average method)
    clust <- hclust(dist, method = 'average')
    
    # Plotting
    plot_heatmap(table, tax)
}

# 6 PCOA ----

# 6.1 Calculating PCOA ----
pcoa_list <- list('otu' = pcoa(d5))

# 7.2 Ploting ----

# I will plot Axis 1 vs Axis 2, and Axis 2 vs Axis 3. Therefore, I will use the first dimension index as a pointer to loop through.
for(i in 1:2){
    plot_pcoa(pcoa_list, ann.colors, factors.for.col, i)
}

# 8 Distance-based RDA ----

# 8.1 Partial RDA ----

# First we fit two partial models. The model starts with a constant and the other variables are added stepwise until significant results are returned. Correlated variables are usually removed by this approach.

# 8.1.1 Partial RDA for factorial variables ----

rda1fact <- capscale(d5 ~ 1, fact)
rda2fact <- capscale(d5 ~ ., fact)
set.seed(1)
rdafact <- ordistep(rda1fact, scope = formula(rda2fact), direction = 'both', perm.max = 200, pstep = 999)
anova.cca(rdafact, step = 1000)

# 8.1.2 Partial RDA for chemical variables ----

rda1chem <- capscale(d5 ~ 1, chem)
rda2chem <- capscale(d5 ~ ., chem)
set.seed(1)
rdachem <- ordistep(rda1chem, scope = formula(rda2chem), direction = 'both', perm.max = 200, pstep = 999)
anova.cca(rdachem, step = 1000)

# It is recommended to check if some of the variables are inflating the model (VIF > 10; Gross, 2003). If that is the case, that variable still presents high correlation with the others and should be removed.
vif.cca(rdachem)

# 8.1.3 Partitioned variance ----

# Now we check how much variation is explained by the factorial variables, how much is explained by the chemical variables, and how much of that is covariation of both types of variables.
chem.names <- attr(rdachem$terms, 'term.labels')
chem.names <- gsub('`', '', chem.names)
chem.pars <- chem[, chem.names]

fact.names <- attr(rdafact$terms, 'term.labels')
fact.pars <- fact[, fact.names, drop = F]

set.seed(1)
spe.part <- varpart(d5, chem.pars, fact.pars)
print(spe.part)
plot(spe.part, digits = 2)

# 8.2 Full RDA ----

# 8.2.1 Building the model ----

env.pars <- cbind(chem.pars, fact.pars)
phylum <- consolidate(taxo16S, 'phylum')
rownames(phylum) <- phylum[, 2]
phylum <- t(phylum[, -c(1, 2)])

set.seed(1)
dbrda <- capscale(d5 ~ . -1, data = env.pars, comm = phylum)
summary(dbrda)

# 8.2.2 Checking colinearity and significance ----

vif.cca(dbrda)
anova(dbrda)
anova(dbrda, by = 'axis')
anova(dbrda, by = 'terms')

# 8.2.3 Plot ----

# I will plot by the 3 scalling factors available
scaling = c(1, 2, 3)
for(i in scaling){
    plot_rda(dbrda, i)
}

# 8.2.4 Checking linearity of species gradients

# For the interpretation, we should check if the species gradients, as represented by the phyla profile, are linear. This is done with DCA: axis lengths < 4 are considered linear (Braak and Smilauer, 2002).
set.seed(1)
decorana(phylum)

# 9 Random Forest ----

# Reading a metadata file. The column 'groups' was filled according to the grouping revealed by the previous analyses

metadata <- read.delim('Part 1 - 16S rRNA gene based/metadata.tsv', sep = '\t', header = T)
metadata <- metadata[!is.na(metadata$groups), ] # Removing sample L2L

# We will investigate the classes involved in group assignment. We drop from the table samples without a group (outliers)

class <- prepare_for_hclust(taxo16S, 'class')
class <- class[rownames(class) %in% metadata$sample, ]

# 9.1 Training a supervised random forest ----

set.seed(1)
rf_list <- list('mangroups' = list('class' = randomForest(class, metadata$groups, importance=TRUE, proximity=TRUE, ntree = 5000)))

# 9.2 Ploting importances ----

imp_names = plot_rf_importances(rf_list)
acc_names = imp_names[[1]]
gini_names = imp_names[[2]]

# 9.3 Correlation between metrics ----

for(factor in names(rf_list)){
    for(level in names(rf_list[[factor]])){
        rf <- rf_list[[factor]][[level]]
        print(c(factor, level, cor(rf$importance[, 'MeanDecreaseAccuracy'], rf$importance[, 'MeanDecreaseGini'])))
    }
}

# 10 CDA ----

class_cda <- class
class_cda$groups <- metadata$groups

# I will keep only the 18 most important taxa according to the RF model
class_cda <- class_cda[, c('groups', acc_names[[factor]][[level]][1:18])]

# Now I need to remove those features where the standard deviation inside a group is 0
class_cda <- formatforcda(class_cda)

# Fitting a linear model
model <- lm(as.matrix(class_cda[, 2:ncol(class_cda)]) ~ groups, data = class_cda)

# Calculating canonical coordinates
cda_list <- list()
cda_list[[factor]][[level]] <- candisc(model, data = class_cda)

# 10.1 Ploting ----

plot_cda(cda_list)

# 10.2 Estimating OOB error ----

class_oob <- class_cda

# The functions have several limitations to characters in features names. Since I do not need the features names, the easiest way to circumvent this is simply changing features names to a simple mask (I am using LETTERS)
colnames(class_oob)[2:ncol(class_oob)] <- LETTERS[2:ncol(class_oob)]
set.seed(1)
tryCatch({print(cdaErrorEst.fun(class_oob, 1, 2:ncol(class_oob)))}, error = function(condition){NA})

# 11 Pairwise t-tests by community structure ----

# Factors to compare
factors <- as.character(unique(metadata$groups))

# Perform T-tests
ttests <- perform_ttests(class, metadata, factors)

# Organize results in the format accepted by the plotting function
results <- list()
factor <- 'mangroups'
level <- 'class'
for(i in 1:length(ttests)){
    names <- names(ttests)
    results[[i]] <- list()
    results[[i]][[factor]][[level]][['ttests']][[names[i]]] <- ttests[[names[i]]]
}

# 11.1 Plotting ----

remove_unclassified <- T

result <- results[[1]]
tweak_sup <- -1.5
tweak_pval <- 1.7
plot_ttest(result, factor, level, remove_unclassified, tweak_sup, tweak_pval)

result <- results[[2]]
tweak_sup <- 0
tweak_pval <- 2
plot_ttest(result, factor, level, remove_unclassified, tweak_sup, tweak_pval)

result <- results[[3]]
tweak_sup <- 0
tweak_pval <- 2
plot_ttest(result, factor, level, remove_unclassified, tweak_sup, tweak_pval)

# 12 Checking enrichment by community structure ----

enrich <- enriched(ttests)

# Taxa enriched for L (positive) compared to both H
g1 <- enrich[['H1 vs L']]
rownames(g1) <- g1$factor; g1 <- g1[, c( -3), drop = F]
colnames(g1) <- c('factor', 'diff_H1', 'p_H1')
g2 <- enrich[['H2 vs L']]
rownames(g2) <- g2$factor; g2 <- g2[, c( -3), drop = F]
colnames(g2) <- c('factor', 'diff_H2', 'p_H2')
taxa <- unlist(sapply(rownames(g1), function(x) x[x %in% rownames(g2)]))
g <- merge(g1[rownames(g1) %in% taxa, ],
           g2[rownames(g2) %in% taxa, ], by.x = 'factor')
g <- g[order(abs(rowMeans(g[, grep('diff', colnames(g))])), decreasing = T), ]
g <- g[(abs(g[, 2]) >= 1)&(abs(g[, 4]) >= 1), ]
print(g)

# Taxa enriched for L compared to H1
taxa <- unlist(sapply(rownames(g1), function(x) x[!(x %in% rownames(g2))]))
g <- g1[rownames(g1) %in% taxa, c('factor', 'diff_H1', 'p_H1')]
rownames(g) <- NULL
g <- g[order(abs(g[, 2]), decreasing = T), ]
g <- g[(abs(g[, 2]) >= 1), ]
print(g)

# Taxa enriched for L compared to H2
taxa <- unlist(sapply(rownames(g2), function(x) x[!(x %in% rownames(g1))]))
g <- g2[rownames(g2) %in% taxa, c('factor', 'diff_H2', 'p_H2')]
rownames(g) <- NULL
g <- g[order(abs(g[, 2]), decreasing = T), ]
g <- g[(abs(g[, 2]) >= 1), ]
print(g)

# Taxa enriched for H1 (positive) compared to H2
g <- enrich[['H1 vs H2']][, c('factor', 'diff', 'p')]
g <- g[order(abs(g[, 2]), decreasing = T), ]
g <- g[(abs(g[, 2]) >= 1), ]
g$diff <- -g$diff
print(g)

save.image('Part 1 - 16S rRNA gene based/16S.RData')
